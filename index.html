<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https: 'unsafe-inline' 'unsafe-eval'">
  <meta name="description" content="Sudan | Displacement Tracking Matrix-Returnees Flow" />
  <title>Sudan Displacement Tracking Matrix</title>
  
  <!-- External CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  
  <!-- Local CSS -->
  <link rel="stylesheet" href="./css/styles.css">
  
  <!-- External JS -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://unpkg.com/esri-leaflet@3.0.0/dist/esri-leaflet.js"></script>
  <script src="https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
  <script src="./src/CanvasFlowmapLayer.js"></script>
  <script src="https://unpkg.com/papaparse@5.3.0/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
</head>

<body>
  <header class="app-header">
    <div class="logo-container">
      <button class="sidebar-toggle" id="sidebarToggle" aria-label="Toggle sidebar">
        <i class="fas fa-bars"></i>
      </button>
      <div>
        <h1 class="app-title">Sudan Displacement Tracking</h1>
        <p class="app-subtitle">Population Distribution & Flow Dashboard</p>
      </div>
    </div>
    <div class="header-controls">
      <button class="btn btn-outline" id="exportBtn">
        <i class="fas fa-download"></i> Export
      </button>
      <button class="btn btn-primary" id="helpBtn">
        <i class="fas fa-question-circle"></i> Help
      </button>
    </div>
  </header>
  
  <div class="main-container">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-section">
        <h2 class="sidebar-title">
          <i class="fas fa-chart-bar"></i> Population Summary
        </h2>
        <div class="data-summary">
          <div class="summary-card idps">
            <h3><i class="fas fa-people-arrows"></i> Total IDPs</h3>
            <div class="value" id="totalIdps">Loading...</div>
            <div class="change" id="idpsChange">
              <i class="fas fa-spinner fa-spin"></i> Loading trend data
            </div>
          </div>
          <div class="summary-card returnees">
            <h3><i class="fas fa-home"></i> Total Returnees</h3>
            <div class="value" id="totalReturnees">Loading...</div>
            <div class="change" id="returneesChange">
              <i class="fas fa-spinner fa-spin"></i> Loading trend data
            </div>
          </div>
        </div>
        
        <div class="chart-container">
          <canvas id="trendChart" aria-label="Population trend chart"></canvas>
        </div>
        
        <div class="time-period-selector">
          <button class="time-period-btn active" data-period="3">3M</button>
          <button class="time-period-btn" data-period="6">6M</button>
          <button class="time-period-btn" data-period="12">1Y</button>
          <button class="time-period-btn" data-period="0">All</button>
        </div>
      </div>
      
      <div class="sidebar-section">
        <h2 class="sidebar-title">
          <i class="fas fa-map-marked-alt"></i> Map Controls
        </h2>
        <div class="map-tabs">
          <button class="map-tab active" data-tab="population" aria-label="Show population map">
            <i class="fas fa-map-marked-alt"></i> Population
          </button>
          <button class="map-tab" data-tab="flow" aria-label="Show flow map">
            <i class="fas fa-project-diagram"></i> Flow
          </button>
        </div>
        <div class="search-container">
          <input type="text" id="state-search" placeholder="Search for a state..." aria-label="Search for a state" />
          <div class="search-results" id="searchResults" role="listbox"></div>
        </div>
      </div>
      
      <div class="sidebar-section">
        <h2 class="sidebar-title">
          <i class="fas fa-info-circle"></i> Key Insights
        </h2>
        <div class="insights-container" id="insightsContainer">
          <p><i class="fas fa-spinner fa-spin"></i> Loading insights...</p>
        </div>
      </div>
      
      <div class="sidebar-section">
        <h2 class="sidebar-title">
          <i class="fas fa-database"></i> Data Sources
        </h2>
        <div class="data-sources-container">
          <p>Data provided by the International Organization for Migration (IOM) through the Displacement Tracking Matrix (DTM).</p>
          <p><strong>Last updated:</strong> <span id="lastUpdated">June 2024</span></p>
          <p><strong>Next update:</strong> <span id="nextUpdate">July 2024</span></p>
        </div>
      </div>
    </aside>
    
    <div class="map-container">
      <div class="map-controls">
        <h2 class="map-title" id="mapTitle">
          <i class="fas fa-map-marked-alt"></i> Population Distribution Map
        </h2>
        <div class="population-toggle" id="populationToggle">
          <button class="toggle-btn active" data-type="idps" aria-label="Show IDP data">
            <i class="fas fa-people-arrows"></i> IDPs
          </button>
          <button class="toggle-btn" data-type="returnees" aria-label="Show returnee data">
            <i class="fas fa-home"></i> Returnees
          </button>
        </div>
        <div class="flow-controls" id="flowControls" style="display: none;">
          <button class="flow-btn" id="resetFlowView" aria-label="Reset flow map view">
            <i class="fas fa-globe-africa"></i> Reset
          </button>
          <button class="flow-btn active" id="toggleAnimation" aria-label="Toggle animation">
            <i class="fas fa-play"></i> Play
          </button>
          <button class="flow-btn active" id="toggleFlows" aria-label="Toggle flow lines">
            <i class="fas fa-wave-square"></i> Flows
          </button>
          <button class="flow-btn active" id="togglePoints" aria-label="Toggle points">
            <i class="fas fa-map-marker-alt"></i> Points
          </button>
        </div>
      </div>
      
      <div class="map-wrapper">
        <div id="population-distribution-map" aria-label="Population distribution map"></div>
        <div id="flow-map" aria-label="Population flow map" style="display: none;"></div>
        <div id="map-loading" class="map-loading">
          <div class="loading-content">
            <i class="fas fa-spinner fa-spin"></i>
            <p>Loading map data...</p>
          </div>
        </div>
        <div id="map-error" class="map-error" style="display: none;">
          <div class="error-content">
            <i class="fas fa-exclamation-triangle"></i>
            <p>Error loading map data. Please try again later.</p>
            <button class="btn btn-primary" id="retryLoadBtn">Retry</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="helpModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Dashboard Help</h2>
        <button class="close-modal" aria-label="Close help modal">&times;</button>
      </div>
      <div class="modal-body">
        <h3>Using the Dashboard</h3>
        <p>This dashboard displays displacement data for Sudan, showing both population distributions and movement flows.</p>
        
        <h4>Population Map</h4>
        <ul>
          <li>Toggle between IDPs (Internally Displaced Persons) and Returnees using the buttons</li>
          <li>Hover over states to see detailed numbers</li>
          <li>Click on states to zoom in</li>
        </ul>
        
        <h4>Flow Map</h4>
        <ul>
          <li>View movement patterns between locations</li>
          <li>Use the controls to play/pause animation and toggle elements</li>
          <li>Click on points to see detailed information</li>
        </ul>
        
        <h3>Data Sources</h3>
        <p>All data comes from the International Organization for Migration (IOM) Displacement Tracking Matrix (DTM).</p>
      </div>
      <div class="modal-footer">
        <button class="btn btn-primary close-modal">Close</button>
      </div>
    </div>
  </div>

  <script>
// Dashboard Configuration
const CONFIG = {
  dataUrls: {
    geojson: './data/ADMIN1.json',
    flowData: './data/IDPs_Pathway.csv',
    metadata: './data/metadata.json'
  },
  mapSettings: {
    initialView: [16, 30],
    populationZoom: 6,
    flowZoom: 5.5,
    mobileZoom: 3,
    maxBounds: [
      [8, 21], // SW
      [23, 39]  // NE
    ]
  },
  colors: {
    idps: ['#eff3ff', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#084594'],
    returnees: [
      'rgba(255, 103, 31, 0.3)',
      'rgba(255, 103, 31, 0.4)',
      'rgba(255, 103, 31, 0.5)',
      'rgba(255, 103, 31, 0.6)',
      'rgba(255, 103, 31, 0.7)',
      'rgba(255, 103, 31, 0.8)',
      'rgba(255, 103, 31, 0.9)'
    ],
    flow: {
      low: '#ffb81c',
      medium: '#ff671f',
      high: '#d22630',
      origin: '#ff671f',
      destination: '#418FDE'
    }
  },
  baseLayers: {
    "Mapbox Custom": 'https://api.mapbox.com/styles/v1/omerosman/cm8oy6is4006101si7ll3bs4h/tiles/{z}/{x}/{y}?access_token=pk.eyJ1Ijoib21lcm9zbWFuIiwiYSI6ImUxZDBkODBlNjQxMDE2M2Y3OTQ3MWIwNTJkMjgzZTI3In0.ekCHuxRflTOO0RpQ6rQR7Q',
    "CartoDB Light": 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
    "OpenStreetMap": 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    "Esri World Imagery": 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
  }
};

// Dashboard State
const STATE = {
  currentDataType: 'idps',
  isAnimationPlaying: false,
  showFlows: true,
  showPoints: true,
  trendPeriod: '3',
  populationData: null,
  flowData: null,
  metadata: null
};

// DOM Elements
const DOM = {
  populationMap: null,
  flowMap: null,
  geojsonLayer: null,
  flowmapLayer: null,
  trendChart: null,
  infoControl: null,
  legendControl: null,
  flowLegendControl: null
};

// Initialize the dashboard when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
  try {
    // Initialize UI components
    initUI();
    
    // Load all data in parallel
    await Promise.all([
      loadMetadata(),
      loadPopulationData(),
      loadFlowData()
    ]);
    
    // Initialize maps and charts
    initPopulationDistributionMap();
    initTrendChart();
    updateInsights();
    
    // Set up event listeners
    setupEventListeners();
    
  } catch (error) {
    console.error("Dashboard initialization failed:", error);
    showError("Failed to initialize dashboard. Please try again later.");
  }
});

// Initialize UI components
function initUI() {
  // Set up sidebar toggle
  document.getElementById('sidebarToggle').addEventListener('click', () => {
    document.getElementById('sidebar').classList.toggle('active');
  });
  
  // Set up help modal
  const helpModal = document.getElementById('helpModal');
  document.getElementById('helpBtn').addEventListener('click', () => {
    helpModal.style.display = 'block';
  });
  
  document.querySelectorAll('.close-modal').forEach(btn => {
    btn.addEventListener('click', () => {
      helpModal.style.display = 'none';
    });
  });
  
  // Close modal when clicking outside
  window.addEventListener('click', (event) => {
    if (event.target === helpModal) {
      helpModal.style.display = 'none';
    }
  });
  
  // Set up retry button
  document.getElementById('retryLoadBtn').addEventListener('click', () => {
    window.location.reload();
  });
}

// Load metadata
async function loadMetadata() {
  try {
    const response = await fetch(CONFIG.dataUrls.metadata);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    STATE.metadata = await response.json();
    
    // Update UI with metadata
    if (STATE.metadata) {
      document.getElementById('lastUpdated').textContent = STATE.metadata.lastUpdated || 'June 2024';
      document.getElementById('nextUpdate').textContent = STATE.metadata.nextUpdate || 'July 2024';
    }
  } catch (error) {
    console.error("Error loading metadata:", error);
    // Continue without metadata
  }
}

// Load population data
async function loadPopulationData() {
  showLoading('population-distribution-map');
  
  try {
    const response = await fetch(CONFIG.dataUrls.geojson);
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    
    const data = await response.json();
    
    // Sample population data - in a real app, this would come from your data source
    const populationData = {
      "North Darfur": { idps: 1762447, returnees: 0, trend: [1500000, 1600000, 1700000, 1762447] },
      "South Darfur": { idps: 1841031, returnees: 0, trend: [1700000, 1750000, 1800000, 1841031] },
      "West Darfur": { idps: 329387, returnees: 0, trend: [300000, 310000, 320000, 329387] },
      "East Darfur": { idps: 794348, returnees: 0, trend: [700000, 750000, 780000, 794348] },
      "Central Darfur": { idps: 936057, returnees: 0, trend: [900000, 920000, 930000, 936057] },
      "Khartoum": { idps: 106919, returnees: 34100, trend: [120000, 110000, 108000, 106919] },
      "Aj Jazirah": { idps: 249740, returnees: 486730, trend: [230000, 240000, 245000, 249740] },
      "White Nile": { idps: 634978, returnees: 0, trend: [600000, 620000, 630000, 634978] },
      "Blue Nile": { idps: 428443, returnees: 0, trend: [400000, 410000, 420000, 428443] },
      "Sennar": { idps: 122589, returnees: 126774, trend: [110000, 115000, 120000, 122589] },
      "Kassala": { idps: 196056, returnees: 0, trend: [180000, 190000, 195000, 196056] },
      "Red Sea": { idps: 226076, returnees: 0, trend: [200000, 210000, 220000, 226076] },
      "Northern": { idps: 537981, returnees: 0, trend: [500000, 520000, 530000, 537981] },
      "River Nile": { idps: 716434, returnees: 0, trend: [680000, 700000, 710000, 716434] },
      "North Kordofan": { idps: 203416, returnees: 0, trend: [190000, 200000, 202000, 203416] },
      "South Kordofan": { idps: 401433, returnees: 0, trend: [380000, 390000, 400000, 401433] },
      "West Kordofan": { idps: 349800, returnees: 0, trend: [330000, 340000, 345000, 349800] },
      "Gedaref": { idps: 701825, returnees: 0, trend: [650000, 680000, 700000, 701825] }
    };
    
    // Calculate totals for the summary cards
    let totalIDPs = 0;
    let totalReturnees = 0;
    
    Object.values(populationData).forEach(state => {
      totalIDPs += state.idps || 0;
      totalReturnees += state.returnees || 0;
    });
    
    // Update summary cards
    document.getElementById('totalIdps').textContent = totalIDPs.toLocaleString();
    document.getElementById('totalReturnees').textContent = totalReturnees.toLocaleString();
    
    // Set trend changes (simplified for example)
    document.getElementById('idpsChange').innerHTML = '<i class="fas fa-arrow-up"></i> 12% increase from last month';
    document.getElementById('returneesChange').innerHTML = '<i class="fas fa-arrow-down"></i> 5% decrease from last month';
    
    // Merge population data with GeoJSON features
    data.features.forEach(feature => {
      const stateName = feature.properties.admin1Name_en;
      
      if (stateName && populationData[stateName]) {
        feature.properties.total_idps = populationData[stateName].idps || 0;
        feature.properties.total_returnees = populationData[stateName].returnees || 0;
        feature.properties.state = stateName;
        feature.properties.trend = populationData[stateName].trend || [];
      } else {
        feature.properties.total_idps = 0;
        feature.properties.total_returnees = 0;
        feature.properties.state = stateName || 'Unknown';
        feature.properties.trend = [];
      }
    });
    
    STATE.populationData = data;
    hideLoading('population-distribution-map');
    
  } catch (error) {
    console.error("Error loading population data:", error);
    showError('population-distribution-map', "Failed to load population data. Please try again later.");
    throw error;
  }
}

// Load flow data
async function loadFlowData() {
  showLoading('flow-map');
  
  try {
    // Using PapaParse to load CSV
    const data = await new Promise((resolve, reject) => {
      Papa.parse(CONFIG.dataUrls.flowData, {
        download: true,
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        complete: (results) => {
          if (results.errors.length > 0) {
            reject(new Error("Error parsing flow data"));
          } else {
            resolve(results.data);
          }
        },
        error: (error) => reject(error)
      });
    });
    
    STATE.flowData = processFlowData(data);
    hideLoading('flow-map');
    
  } catch (error) {
    console.error("Error loading flow data:", error);
    showError('flow-map', "Failed to load flow data. Please try again later.");
    throw error;
  }
}

// Process flow data from CSV to GeoJSON format
function processFlowData(data) {
  return {
    type: 'FeatureCollection',
    features: data.map(datum => ({
      type: 'Feature',
      geometry: { 
        type: 'Point', 
        coordinates: [
          parseFloat(datum.s_lon) || 0,
          parseFloat(datum.s_lat) || 0
        ] 
      },
      properties: {
        s_state_id: datum.s_state_id,
        s_State: datum.s_State,
        s_lat: parseFloat(datum.s_lat) || 0,
        s_lon: parseFloat(datum.s_lon) || 0,
        e_locality_id: datum.e_locality_id,
        e_locality: datum.e_locality,
        e_lat: parseFloat(datum.e_lat) || 0,
        e_lon: parseFloat(datum.e_lon) || 0,
        e_Volume: parseFloat(datum.e_Volume) || 0,
        main_needs: datum.main_needs
      }
    }))
  };
}

// Initialize the Population Distribution map
function initPopulationDistributionMap() {
  if (!STATE.populationData) {
    throw new Error("Population data not loaded");
  }
  
  try {
    // Initialize the map
    DOM.populationMap = L.map('population-distribution-map', {
      zoomControl: false,
      attributionControl: false,
      maxBounds: CONFIG.mapSettings.maxBounds,
      maxBoundsViscosity: 1.0
    }).setView(
      CONFIG.mapSettings.initialView,
      L.Browser.mobile ? CONFIG.mapSettings.mobileZoom : CONFIG.mapSettings.populationZoom
    );
    
    // Add zoom control
    L.control.zoom({ position: 'topright' }).addTo(DOM.populationMap);
    
    // Add base layers
    const baseLayers = {};
    Object.entries(CONFIG.baseLayers).forEach(([name, url]) => {
      baseLayers[name] = L.tileLayer(url, {
        attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        tileSize: 512,
        zoomOffset: -1,
        maxZoom: 18
      });
    });
    
    // Add default base layer
    baseLayers["Mapbox Custom"].addTo(DOM.populationMap);
    
    // Add layer control
    L.control.layers(baseLayers, null, {
      position: 'bottomleft',
      collapsed: false
    }).addTo(DOM.populationMap);
    
    // Define style function
    function style(feature) {
      return {
        fillColor: getColor(feature.properties[`total_${STATE.currentDataType}`] || 0),
        weight: 2,
        opacity: 1,
        color: 'white',
        dashArray: '3',
        fillOpacity: 0.7
      };
    }
    
    // Add hover interactions
    function highlightFeature(e) {
      const layer = e.target;
      
      layer.setStyle({
        weight: 5,
        color: '#666',
        dashArray: '',
        fillOpacity: 0.7
      });
      
      if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
        layer.bringToFront();
      }
      
      DOM.infoControl.update(layer.feature.properties);
      updateTrendChart(layer.feature.properties);
    }
    
    function resetHighlight(e) {
      DOM.geojsonLayer.resetStyle(e.target);
      DOM.infoControl.update();
      resetTrendChart();
    }
    
    function zoomToFeature(e) {
      DOM.populationMap.fitBounds(e.target.getBounds(), {
        padding: [50, 50],
        maxZoom: 8
      });
    }
    
    function onEachFeature(feature, layer) {
      layer.on({
        mouseover: highlightFeature,
        mouseout: resetHighlight,
        click: zoomToFeature
      });
    }
    
    // Add GeoJSON layer
    DOM.geojsonLayer = L.geoJSON(STATE.populationData, {
      style: style,
      onEachFeature: onEachFeature
    }).addTo(DOM.populationMap);
    
    // Fit map to bounds of all features
    DOM.populationMap.fitBounds(DOM.geojsonLayer.getBounds(), {
      padding: [50, 50]
    });
    
    // Add info control
    DOM.infoControl = L.control({ position: 'topleft' });
    
    DOM.infoControl.onAdd = function() {
      this._div = L.DomUtil.create('div', 'info');
      this.update();
      return this._div;
    };
    
    DOM.infoControl.update = function(props) {
      let title, valueLabel;
      
      switch(STATE.currentDataType) {
        case 'idps':
          title = 'IDP Distribution';
          valueLabel = 'IDPs';
          break;
        case 'returnees':
          title = 'Returnee Distribution';
          valueLabel = 'Returnees';
          break;
      }
      
      this._div.innerHTML = `<h4>Sudan ${title}</h4>` + 
        (props ? 
          `<b>${props.state}</b><br />` + 
          (props[`total_${STATE.currentDataType}`] || 0).toLocaleString() + 
          ` ${valueLabel}` : 
          'Hover over a state');
    };
    
    DOM.infoControl.addTo(DOM.populationMap);
    
    // Add legend control
    DOM.legendControl = L.control({ position: 'bottomright' });
    
    DOM.legendControl.onAdd = function() {
      const div = L.DomUtil.create('div', 'info legend population-legend');
      updateLegend(div);
      return div;
    };
    
    DOM.legendControl.addTo(DOM.populationMap);
    
    // Initialize search functionality
    initSearch();
    
  } catch (error) {
    console.error("Error initializing population map:", error);
    throw error;
  }
}

// Initialize the flow map
function initFlowMap() {
  if (!STATE.flowData) {
    throw new Error("Flow data not loaded");
  }
  
  try {
    // Initialize the flow map
    DOM.flowMap = L.map('flow-map', {
      zoomControl: false,
      attributionControl: false,
      maxBounds: CONFIG.mapSettings.maxBounds,
      maxBoundsViscosity: 1.0
    }).setView(CONFIG.mapSettings.initialView, CONFIG.mapSettings.flowZoom);
    
    // Add zoom control
    L.control.zoom({ position: 'topright' }).addTo(DOM.flowMap);
    
    // Add base layers
    const baseLayers = {};
    Object.entries(CONFIG.baseLayers).forEach(([name, url]) => {
      baseLayers[name] = L.tileLayer(url, {
        attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        tileSize: 512,
        zoomOffset: -1,
        maxZoom: 18
      });
    });
    
    // Add default base layer
    baseLayers["Mapbox Custom"].addTo(DOM.flowMap);
    
    // Add layer control
    L.control.layers(baseLayers, null, {
      position: 'bottomleft',
      collapsed: false
    }).addTo(DOM.flowMap);
    
    // State boundaries layer (for reference)
    if (STATE.populationData) {
      L.geoJSON(STATE.populationData, {
        style: {
          color: '#555',
          weight: 1,
          opacity: 0.7,
          fillOpacity: 0.1
        }
      }).addTo(DOM.flowMap);
    }
    
    // Initialize flowmap layer
    initializeFlowmapLayer();
    
  } catch (error) {
    console.error("Error initializing flow map:", error);
    throw error;
  }
}

// Initialize flowmap layer with processed data
function initializeFlowmapLayer() {
  // Create flowmap layer
  DOM.flowmapLayer = L.canvasFlowmapLayer(STATE.flowData, {
    originAndDestinationFieldIds: {
      originUniqueIdField: 's_state_id',
      originGeometry: { x: 's_lon', y: 's_lat' },
      destinationUniqueIdField: 'e_locality_id',
      destinationGeometry: { x: 'e_lon', y: 'e_lat' }
    },
    style: (feature) => {
      const baseRadius = 10;
      const maxRadius = 6;
      const volume = feature.properties.e_Volume || 0;
      
      // Different styles for origin and destination points
      const radius = feature.properties.isOrigin
        ? baseRadius
        : Math.min(baseRadius + (volume / 5000), maxRadius);
      
      return {
        radius: radius,
        weight: 1,
        color: '#fff',
        fillColor: feature.properties.isOrigin ? CONFIG.colors.flow.origin : CONFIG.colors.flow.destination,
        fillOpacity: feature.properties.isOrigin ? 0.8 : 0.7
      };
    },
    canvasBezierStyle: {
      type: 'classBreaks',
      field: 'e_Volume',
      classBreakInfos: [
        { 
          classMinValue: 1, 
          classMaxValue: 80000, 
          symbol: { 
            strokeStyle: CONFIG.colors.flow.low, 
            lineWidth: 0.5, 
            lineCap: 'round', 
            shadowColor: '#fee8c8', 
            shadowBlur: 2.0 
          } 
        },
        { 
          classMinValue: 80001, 
          classMaxValue: 1000000, 
          symbol: { 
            strokeStyle: CONFIG.colors.flow.medium, 
            lineWidth: 1.5, 
            lineCap: 'round', 
            shadowColor: '#fdbb84', 
            shadowBlur: 2.0 
          } 
        },
        { 
          classMinValue: 1000001, 
          classMaxValue: 160000, 
          symbol: { 
            strokeStyle: CONFIG.colors.flow.high, 
            lineWidth: 3, 
            lineCap: 'round', 
            shadowColor: '#e34a33', 
            shadowBlur: 2.0 
          } 
        }
      ],
      defaultSymbol: { 
        strokeStyle: '#e7e1ef', 
        lineWidth: 0.5, 
        lineCap: 'round', 
        shadowColor: '#e7e1ef', 
        shadowBlur: 1.5 
      }
    },
    pathDisplayMode: 'all',
    animationStarted: true,
    animationEasingFamily: 'Linear',
    animationEasingType: 'None',
    animationDuration: 3000,
    onEachFeature: addFlowTooltip
  }).addTo(DOM.flowMap);
  
  // Set initial UI states
  STATE.isAnimationPlaying = true;
  STATE.showFlows = true;
  STATE.showPoints = true;
  updateAnimationButton();
  updateFlowsButton();
  updatePointsButton();
  
  // Highlight paths on mouseover
  DOM.flowmapLayer.on('mouseover', (e) => {
    if (e.sharedOriginFeatures.length) {
      DOM.flowmapLayer.selectFeaturesForPathDisplay(e.sharedOriginFeatures, 'SELECTION_NEW');
    }
    if (e.sharedDestinationFeatures.length) {
      DOM.flowmapLayer.selectFeaturesForPathDisplay(e.sharedDestinationFeatures, 'SELECTION_NEW');
    }
  });
  
  // Select initial feature for path display (Khartoum)
  DOM.flowmapLayer.selectFeaturesForPathDisplayById('s_state_id', "SD15", true, 'SELECTION_NEW');
  
  // Add flow legend
  DOM.flowLegendControl = L.control({ position: 'bottomright' });
  
  DOM.flowLegendControl.onAdd = function() {
    const div = L.DomUtil.create('div', 'flow-legend');
    div.innerHTML = `
      <h4>IDP Flow Volume</h4>
      <div class="flow-legend-item">
        <div class="flow-legend-color" style="background:${CONFIG.colors.flow.low}"></div>
        <span>&lt; 80,000 IDPs</span>
      </div>
      <div class="flow-legend-item">
        <div class="flow-legend-color" style="background:${CONFIG.colors.flow.medium}"></div>
        <span>80,000 - 1M IDPs</span>
      </div>
      <div class="flow-legend-item">
        <div class="flow-legend-color" style="background:${CONFIG.colors.flow.high}"></div>
        <span>&gt; 1M IDPs</span>
      </div>
      <hr style="margin: 8px 0; border-color: #eee;">
      <div class="flow-legend-item">
        <div class="flow-legend-color" style="background:${CONFIG.colors.flow.destination}"></div>
        <span>Destination Points</span>
      </div>
      <div class="flow-legend-item">
        <div class="flow-legend-color" style="background:${CONFIG.colors.flow.origin}"></div>
        <span>Origin Points</span>
      </div>
    `;
    return div;
  };
  
  DOM.flowLegendControl.addTo(DOM.flowMap);
}

// Initialize search functionality
function initSearch() {
  const stateSearch = document.getElementById('state-search');
  const searchResults = document.getElementById('searchResults');
  
  if (!stateSearch || !searchResults) return;
  
  // Debounce search input
  const debounceSearch = debounce(function() {
    const searchTerm = this.value.toLowerCase().trim();
    
    if (searchTerm.length < 2) {
      searchResults.style.display = 'none';
      return;
    }
    
    const matchingFeatures = STATE.populationData.features.filter(feature => {
      return feature.properties.state.toLowerCase().includes(searchTerm);
    });
    
    if (matchingFeatures.length > 0) {
      searchResults.innerHTML = matchingFeatures.map(feature => {
        return `<div role="option" data-state="${feature.properties.state}">${feature.properties.state}</div>`;
      }).join('');
      searchResults.style.display = 'block';
    } else {
      searchResults.innerHTML = '<div role="option">No matching states found</div>';
      searchResults.style.display = 'block';
    }
  }, 300);
  
  stateSearch.addEventListener('input', debounceSearch);
  
  // Handle click on search results
  searchResults.addEventListener('click', function(e) {
    if (e.target.tagName === 'DIV' && e.target.dataset.state) {
      const stateName = e.target.dataset.state;
      stateSearch.value = stateName;
      searchResults.style.display = 'none';
      
      // Find and zoom to the feature
      const feature = STATE.populationData.features.find(f => f.properties.state === stateName);
      if (feature) {
        const layer = DOM.geojsonLayer.getLayers().find(l => l.feature.properties.state === stateName);
        if (layer) {
          DOM.populationMap.fitBounds(layer.getBounds(), {
            padding: [50, 50],
            maxZoom: 8
          });
          layer.fire('mouseover'); // Trigger hover effect
        }
      }
    }
  });
  
  // Close search results when clicking outside
  document.addEventListener('click', function(e) {
    if (e.target !== stateSearch) {
      searchResults.style.display = 'none';
    }
  });
  
  // Keyboard navigation for search results
  stateSearch.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
      const options = searchResults.querySelectorAll('[role="option"]');
      if (options.length === 0) return;
      
      let currentIndex = -1;
      options.forEach((option, index) => {
        if (option.classList.contains('highlighted')) {
          currentIndex = index;
          option.classList.remove('highlighted');
        }
      });
      
      if (e.key === 'ArrowDown') {
        currentIndex = (currentIndex + 1) % options.length;
      } else {
        currentIndex = (currentIndex - 1 + options.length) % options.length;
      }
      
      options[currentIndex].classList.add('highlighted');
      options[currentIndex].scrollIntoView({ block: 'nearest' });
    } else if (e.key === 'Enter') {
      const highlighted = searchResults.querySelector('.highlighted');
      if (highlighted) {
        highlighted.click();
      }
    }
  });
}

// Initialize trend chart
function initTrendChart() {
  const ctx = document.getElementById('trendChart').getContext('2d');
  
  DOM.trendChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: ['Mar', 'Apr', 'May', 'Jun'],
      datasets: [
        {
          label: 'IDPs',
          data: [8000000, 8500000, 9200000, 9842000],
          borderColor: '#2A6FBB',
          backgroundColor: 'rgba(42, 111, 187, 0.1)',
          borderWidth: 2,
          tension: 0.3,
          fill: true
        },
        {
          label: 'Returnees',
          data: [550000, 600000, 620000, 647604],
          borderColor: '#FF671F',
          backgroundColor: 'rgba(255, 103, 31, 0.1)',
          borderWidth: 2,
          tension: 0.3,
          fill: true
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          mode: 'index',
          intersect: false,
          callbacks: {
            label: function(context) {
              let label = context.dataset.label || '';
              if (label) {
                label += ': ';
              }
              label += context.raw.toLocaleString();
              return label;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: false,
          ticks: {
            callback: function(value) {
              if (value >= 1000000) {
                return (value / 1000000).toFixed(1) + 'M';
              } else if (value >= 1000) {
                return (value / 1000).toFixed(0) + 'K';
              }
              return value;
            }
          },
          grid: {
            color: 'rgba(0, 0, 0, 0.05)'
          }
        },
        x: {
          grid: {
            display: false
          }
        }
      },
      interaction: {
        mode: 'nearest',
        axis: 'x',
        intersect: false
      }
    }
  });
}

// Update trend chart when hovering over a state
function updateTrendChart(props) {
  if (!props || !props.trend || props.trend.length === 0) return;
  
  DOM.trendChart.data.datasets[0].data = props.trend;
  DOM.trendChart.data.datasets[1].data = [];
  DOM.trendChart.update();
}

// Reset trend chart to show national data
function resetTrendChart() {
  DOM.trendChart.data.datasets[0].data = [8000000, 8500000, 9200000, 9842000];
  DOM.trendChart.data.datasets[1].data = [550000, 600000, 620000, 647604];
  DOM.trendChart.update();
}

// Update insights based on current data
function updateInsights() {
  const insightsContainer = document.getElementById('insightsContainer');
  if (!insightsContainer) return;
  
  // In a real app, these would be generated from the data
  insightsContainer.innerHTML = `
    <p><strong>Darfur Region:</strong> Accounts for 45% of total IDPs with increasing displacement due to ongoing conflict.</p>
    <p><strong>Khartoum State:</strong> Highest number of returnees (34,100) as security improves in some areas.</p>
    <p><strong>Aj Jazirah:</strong> Significant returnee population (486,730) with established humanitarian corridors.</p>
  `;
}

// Add tooltip and popup to flow features
function addFlowTooltip(feature, layer) {
  const tooltipContent = feature.properties.isOrigin
    ? `Displacement From: ${feature.properties.s_State}`
    : `Displacement To: ${feature.properties.e_locality}`;
  
  layer.bindTooltip(tooltipContent);
  layer.on('mouseover', () => layer.openTooltip());
  layer.on('mouseout', () => layer.closeTooltip());
  
  // Add popup with more detailed information
  const popupContent = feature.properties.isOrigin
    ? `<div style="min-width: 200px;">
         <h4 style="margin: 0 0 10px; color: #2a5885;">Displacement Origin</h4>
         <p><strong>State:</strong> ${feature.properties.s_State}</p>
         <p><strong>Main Needs:</strong> ${feature.properties.main_needs || 'Not specified'}</p>
         <p><small>Click to view destination flows</small></p>
       </div>`
    : `<div style="min-width: 200px;">
         <h4 style="margin: 0 0 10px; color: #2a5885;">Displacement Destination</h4>
         <p><strong>Location:</strong> ${feature.properties.e_locality}</p>
         <p><strong>Total Displaced Population:</strong> ${feature.properties.e_Volume ? feature.properties.e_Volume.toLocaleString() : 'N/A'}</p>
         <p><strong>Main Needs:</strong> ${feature.properties.main_needs || 'Not specified'}</p>
       </div>`;
  
  layer.bindPopup(popupContent);
}

// Get color based on value and current data type
function getColor(d) {
  const colorScale = STATE.currentDataType === 'idps' ? CONFIG.colors.idps : CONFIG.colors.returnees;
  
  return d > 1000000 ? colorScale[6] :
         d > 500000  ? colorScale[5] :
         d > 200000  ? colorScale[4] :
         d > 100000  ? colorScale[3] :
         d > 50000   ? colorScale[2] :
         d > 20000   ? colorScale[1] :
                       colorScale[0];
}

// Update legend content
function updateLegend(legendDiv) {
  let grades, title, colorScale;
  
  switch(STATE.currentDataType) {
    case 'idps':
      grades = [0, 50000, 100000, 200000, 500000, 1000000];
      title = 'IDPs';
      colorScale = CONFIG.colors.idps;
      break;
    case 'returnees':
      grades = [0, 50000, 100000, 200000, 500000, 1000000];
      title = 'Returnees';
      colorScale = CONFIG.colors.returnees;
      break;
  }
  
  legendDiv.innerHTML = `<h4>${title}</h4>`;
  
  // Loop through population intervals and generate a label with a colored square for each interval
  for (let i = 0; i < grades.length; i++) {
    legendDiv.innerHTML +=
      '<i style="background:' + colorScale[i + 1] + '"></i> ' +
      grades[i].toLocaleString() + (grades[i + 1] ? '&ndash;' + grades[i + 1].toLocaleString() + '<br>' : '+');
  }
}

// Update map display based on selected data type
function updateMapDisplay(dataType) {
  STATE.currentDataType = dataType;
  
  // Update the legend
  if (DOM.legendControl) {
    const legendDiv = DOM.legendControl.getContainer();
    if (legendDiv) updateLegend(legendDiv);
  }
  
  // Update the style and info display
  DOM.geojsonLayer.setStyle(feature => {
    const value = feature.properties[`total_${dataType}`] || 0;
    return {
      fillColor: getColor(value),
      weight: 2,
      opacity: 1,
      color: 'white',
      dashArray: '3',
      fillOpacity: 0.7
    };
  });
  
  // Update the info control function
  DOM.infoControl.update = function(props) {
    let title, valueLabel;
    
    switch(dataType) {
      case 'idps':
        title = 'IDP Distribution';
        valueLabel = 'IDPs';
        break;
      case 'returnees':
        title = 'Returnee Distribution';
        valueLabel = 'Returnees';
        break;
    }
    
    this._div.innerHTML = `<h4>Sudan ${title}</h4>` + 
      (props ? 
        `<b>${props.state}</b><br />` + 
        (props[`total_${dataType}`] || 0).toLocaleString() + 
        ` ${valueLabel}` : 
        'Hover over a state');
  };
  
  // Trigger an update for the info control
  DOM.infoControl.update();
}

// Update animation button state
function updateAnimationButton() {
  const button = document.getElementById('toggleAnimation');
  const icon = button.querySelector('i');
  
  if (STATE.isAnimationPlaying) {
    icon.className = 'fas fa-pause';
    button.innerHTML = '<i class="fas fa-pause"></i> Pause';
  } else {
    icon.className = 'fas fa-play';
    button.innerHTML = '<i class="fas fa-play"></i> Play';
  }
}

// Update flows button state
function updateFlowsButton() {
  const button = document.getElementById('toggleFlows');
  button.innerHTML = `<i class="fas fa-wave-square"></i> ${STATE.showFlows ? 'Hide' : 'Show'} Flows`;
}

// Update points button state
function updatePointsButton() {
  const button = document.getElementById('togglePoints');
  button.innerHTML = `<i class="fas fa-map-marker-alt"></i> ${STATE.showPoints ? 'Hide' : 'Show'} Points`;
}

// Set up event listeners
function setupEventListeners() {
  // Tab switching functionality
  document.querySelectorAll('.map-tab').forEach(button => {
    button.addEventListener('click', () => {
      // Remove active class from all buttons
      document.querySelectorAll('.map-tab').forEach(btn => btn.classList.remove('active'));
      // Add active class to the clicked button
      button.classList.add('active');
      
      // Show the appropriate map
      const tab = button.dataset.tab;
      if (tab === 'population') {
        document.getElementById('population-distribution-map').style.display = 'block';
        document.getElementById('flow-map').style.display = 'none';
        document.getElementById('populationToggle').style.display = 'flex';
        document.getElementById('flowControls').style.display = 'none';
        document.getElementById('mapTitle').innerHTML = '<i class="fas fa-map-marked-alt"></i> Population Distribution Map';
      } else if (tab === 'flow') {
        document.getElementById('population-distribution-map').style.display = 'none';
        document.getElementById('flow-map').style.display = 'block';
        document.getElementById('populationToggle').style.display = 'none';
        document.getElementById('flowControls').style.display = 'flex';
        document.getElementById('mapTitle').innerHTML = '<i class="fas fa-project-diagram"></i> IDP Pathways Flow Map';
        
        // Initialize flow map if not already done
        if (!DOM.flowMap) {
          initFlowMap();
        }
      }
    });
  });
  
  // Toggle buttons functionality
  document.querySelectorAll('.population-toggle .toggle-btn').forEach(button => {
    button.addEventListener('click', () => {
      // Remove active class from all buttons
      document.querySelectorAll('.population-toggle .toggle-btn').forEach(btn => btn.classList.remove('active'));
      // Add active class to the clicked button
      button.classList.add('active');
      // Update the map display
      updateMapDisplay(button.dataset.type);
    });
  });
  
  // Time period selector
  document.querySelectorAll('.time-period-btn').forEach(button => {
    button.addEventListener('click', () => {
      // Remove active class from all buttons
      document.querySelectorAll('.time-period-btn').forEach(btn => btn.classList.remove('active'));
      // Add active class to the clicked button
      button.classList.add('active');
      
      // Update trend chart based on period
      STATE.trendPeriod = button.dataset.period;
      updateTrendPeriod();
    });
  });
  
  // Flow map controls
  document.getElementById('resetFlowView').addEventListener('click', () => {
    if (DOM.flowMap) {
      DOM.flowMap.setView(CONFIG.mapSettings.initialView, CONFIG.mapSettings.flowZoom);
    }
  });
  
  document.getElementById('toggleAnimation').addEventListener('click', () => {
    STATE.isAnimationPlaying = !STATE.isAnimationPlaying;
    if (DOM.flowmapLayer) {
      DOM.flowmapLayer.setAnimationStarted(STATE.isAnimationPlaying);
    }
    updateAnimationButton();
  });
  
  document.getElementById('toggleFlows').addEventListener('click', () => {
    STATE.showFlows = !STATE.showFlows;
    if (DOM.flowmapLayer) {
      DOM.flowmapLayer.setPathDisplayMode(STATE.showFlows ? 'all' : 'none');
    }
    updateFlowsButton();
  });
  
  document.getElementById('togglePoints').addEventListener('click', () => {
    STATE.showPoints = !STATE.showPoints;
    if (DOM.flowmapLayer) {
      DOM.flowmapLayer.setPointVisibility(STATE.showPoints);
    }
    updatePointsButton();
  });
  
  // Export button
  document.getElementById('exportBtn').addEventListener('click', () => {
    // In a real app, this would export data or images
    alert('Export functionality would be implemented here');
  });
}

// Update trend chart based on selected period
function updateTrendPeriod() {
  // In a real app, this would fetch different time periods of data
  console.log(`Updating trend chart for ${STATE.trendPeriod} months`);
}

// Show loading state for a map
function showLoading(mapId) {
  const mapElement = document.getElementById(mapId);
  if (mapElement) {
    mapElement.style.display = 'none';
  }
  
  const loadingElement = document.getElementById('map-loading');
  if (loadingElement) {
    loadingElement.style.display = 'flex';
  }
  
  const errorElement = document.getElementById('map-error');
  if (errorElement) {
    errorElement.style.display = 'none';
  }
}

// Hide loading state for a map
function hideLoading(mapId) {
  const mapElement = document.getElementById(mapId);
  if (mapElement) {
    mapElement.style.display = 'block';
  }
  
  const loadingElement = document.getElementById('map-loading');
  if (loadingElement) {
    loadingElement.style.display = 'none';
  }
}

// Show error state for a map
function showError(mapId, message) {
  const mapElement = document.getElementById(mapId);
  if (mapElement) {
    mapElement.style.display = 'none';
  }
  
  const loadingElement = document.getElementById('map-loading');
  if (loadingElement) {
    loadingElement.style.display = 'none';
  }
  
  const errorElement = document.getElementById('map-error');
  if (errorElement) {
    errorElement.style.display = 'flex';
    if (message) {
      errorElement.querySelector('p').textContent = message;
    }
  }
}

// Debounce function for search input
function debounce(func, wait) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}
</script>
</body>
</html>
